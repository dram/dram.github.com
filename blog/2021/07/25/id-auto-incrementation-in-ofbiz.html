<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/css/main.css"><link rel="shortcut icon" href="/images/favicon.png"><title>OFBiz中的ID自增机制</title></head><body><header><span id="site-name"><a href="/">dram.me</a></span><nav><ul><li><a href="/blog/about.html">About</a></li><li><a href="/logo/">LOGO</a></li></ul></nav></header><article><h1 class="topictitle1" id="ariaid-title1">OFBiz中的ID自增机制</h1><time>25 Jul 2021</time><div><p>由于考虑多数据库的支持，OFBiz在ID自增处理上，没有依赖数据库特性，而是程序逻辑实现。</p><p>数据库中有一个表用于存放ID序列信息：<code>sequence_value_item</code>，在<code>getNextSeqIdLong</code>中有涉及对该表的操作，相关代码还包括<code>getNextSeqId</code>、<code>setNextSubSeqId</code>和<code>make-next-seq-id</code>。</p><p><code>EntityAutoEngine</code>中的<code>invokeCreate</code>中也有涉及相关操作。</p><p>大概的逻辑（部分猜测）：</p><p>sequence_value_item存放的是大的序列块，因为涉及到性能问题，所以又引入了SequenceBank作为缓存。需要新ID时，先从bank取，如果bank中已经空了，bank从sequence_value_item申请一块新的。</p><p>按照这样的分析，在导出数据的时候，只需要再导出sequence_value_item表即可。</p><p>序列号中间可能中断，也是因为bank作为内存中的缓存，如果服务强制退出，这部分缓存的序列号就会丢失，下次重新启动时，又是从sequence_value_item获取新的起始值。</p></div></article><footer><p>Copyright © 2021 Xin Wang</p></footer></body></html>